"""
IBM TrustBuild — Stage 4: Secure Code Synthesis Agent
Generates the final deployment kit: Dockerfile, Terraform, app boilerplate,
and IBM Cloud CLI commands. Uses granite-20b-code.
Only runs after the Governance Guardrail has PASSED or CORRECTED.
"""

import time
import logging
from services.watsonx_client import watsonx
from models.schemas import (
    CodeSynthesisResult,
    GeneratedFile,
    StageStatus,
    StageResult,
)

logger = logging.getLogger("trustbuild.codegen_agent")


# ─────────────────────────────────────────────────────────────────
# Code Templates
# These templates are parameterized based on the manifest.
# In production, granite-20b-code would generate these dynamically.
# For the hackathon demo, we use intelligent templates that adapt
# to the detected services and security requirements.
# ─────────────────────────────────────────────────────────────────

def _generate_dockerfile(manifest: dict, sensitivity: str) -> str:
    """Generate a security-hardened Dockerfile based on the manifest."""
    base_image = "python:3.11-slim"
    port = 8080

    lines = [
        f"# IBM TrustBuild — Auto-Generated Dockerfile",
        f"# Governance Status: COMPLIANT",
        f"# Data Sensitivity: {sensitivity}",
        f"# Generated by: IBM TrustBuild (watsonx.ai + Granite)",
        f"",
        f"FROM {base_image}",
        f"",
        f"# Security: Run as non-root user",
        f"RUN groupadd -r appuser && useradd -r -g appuser appuser",
        f"",
        f"WORKDIR /app",
        f"",
        f"# Install dependencies",
        f"COPY requirements.txt .",
        f"RUN pip install --no-cache-dir -r requirements.txt",
        f"",
        f"# Copy application code",
        f"COPY . .",
        f"",
        f"# Security: Set ownership",
        f"RUN chown -R appuser:appuser /app",
        f"USER appuser",
        f"",
    ]

    if sensitivity in ("PHI", "PCI"):
        lines.extend([
            f"# Security: Enforce TLS and secure headers",
            f"ENV FORCE_TLS=true",
            f"ENV SECURE_HEADERS=true",
            f"ENV AUDIT_LOGGING=true",
            f"",
        ])

    lines.extend([
        f"# Health check for IBM Code Engine",
        f"HEALTHCHECK --interval=30s --timeout=3s \\",
        f"  CMD curl -f http://localhost:{port}/health || exit 1",
        f"",
        f"EXPOSE {port}",
        f"",
        f"ENTRYPOINT [\"python\", \"-m\", \"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"{port}\"]",
    ])

    return "\n".join(lines)


def _generate_terraform(manifest: dict, sensitivity: str) -> str:
    """Generate Terraform IaC for IBM Cloud provisioning."""
    services = manifest.get("services", [])
    networking = manifest.get("networking", {})
    security = manifest.get("security_config", {})

    lines = [
        '# IBM TrustBuild — Auto-Generated Terraform',
        '# Governance Status: COMPLIANT',
        f'# Data Sensitivity: {sensitivity}',
        '',
        'terraform {',
        '  required_providers {',
        '    ibm = {',
        '      source  = "IBM-Cloud/ibm"',
        '      version = "~> 1.60"',
        '    }',
        '  }',
        '}',
        '',
        'provider "ibm" {',
        '  ibmcloud_api_key = var.ibmcloud_api_key',
        '  region           = "us-south"',
        '}',
        '',
        'variable "ibmcloud_api_key" {',
        '  description = "IBM Cloud API Key"',
        '  sensitive   = true',
        '}',
        '',
    ]

    # VPC resource if needed
    if networking.get("vpc_enabled"):
        lines.extend([
            '# VPC for network isolation',
            'resource "ibm_is_vpc" "trustbuild_vpc" {',
            '  name = "trustbuild-vpc"',
            '}',
            '',
            'resource "ibm_is_subnet" "trustbuild_subnet" {',
            '  name                     = "trustbuild-subnet"',
            '  vpc                      = ibm_is_vpc.trustbuild_vpc.id',
            '  zone                     = "us-south-1"',
            '  available_ipv4_address_count = 256',
            '}',
            '',
        ])

    # Code Engine project
    lines.extend([
        '# IBM Code Engine — Serverless Compute',
        'resource "ibm_code_engine_project" "trustbuild_project" {',
        '  name      = "trustbuild-project"',
        '  resource_group_id = var.resource_group_id',
        '}',
        '',
    ])

    # Database resources
    for svc in services:
        if svc.get("role") == "database":
            if "Cloudant" in svc.get("service_name", ""):
                plan = svc.get("plan", "standard")
                lines.extend([
                    f'# IBM Cloudant — NoSQL Database ({plan} tier)',
                    'resource "ibm_cloudant_instance" "trustbuild_db" {',
                    f'  name              = "trustbuild-cloudant"',
                    f'  plan              = "{plan}"',
                    f'  region_location   = "us-south"',
                    f'  resource_group_id = var.resource_group_id',
                    '}',
                    '',
                ])

    # Key Protect if encryption is specified
    if security.get("encryption_at_rest"):
        lines.extend([
            '# IBM Key Protect — Encryption Key Management',
            'resource "ibm_kms_instance" "trustbuild_kms" {',
            '  name              = "trustbuild-key-protect"',
            '  plan              = "standard"',
            '  resource_group_id = var.resource_group_id',
            '}',
            '',
        ])

    lines.extend([
        'variable "resource_group_id" {',
        '  description = "IBM Cloud Resource Group ID"',
        '}',
        '',
        'output "project_id" {',
        '  value = ibm_code_engine_project.trustbuild_project.id',
        '}',
    ])

    return "\n".join(lines)


def _generate_app_boilerplate(manifest: dict, sensitivity: str) -> str:
    """Generate the main application boilerplate with IBM SDK integrations."""
    services = manifest.get("services", [])
    has_cloudant = any("Cloudant" in s.get("service_name", "") for s in services)
    has_watsonx = any("watsonx" in s.get("service_name", "") for s in services)

    lines = [
        '"""',
        'IBM TrustBuild — Auto-Generated Application Boilerplate',
        'Governance Status: COMPLIANT',
        f'Data Sensitivity: {sensitivity}',
        'Generated by: IBM TrustBuild (watsonx.ai + Granite)',
        '"""',
        '',
        'import os',
        'import logging',
        'from fastapi import FastAPI, HTTPException',
        'from pydantic import BaseModel',
        '',
    ]

    if has_cloudant:
        lines.extend([
            'from ibmcloudant import CloudantV1',
            '',
        ])

    if has_watsonx:
        lines.extend([
            'from ibm_watsonx_ai import WatsonxAI',
            '',
        ])

    lines.extend([
        '# ── Logging Configuration ──',
        'logging.basicConfig(level=logging.INFO)',
        'logger = logging.getLogger("trustbuild-app")',
        '',
        '# ── Application Setup ──',
        'app = FastAPI(title="TrustBuild App", version="1.0.0")',
        '',
    ])

    if has_cloudant:
        lines.extend([
            '# ── IBM Cloudant Client ──',
            'cloudant_url = os.getenv("CLOUDANT_URL", "")',
            'cloudant_apikey = os.getenv("CLOUDANT_APIKEY", "")',
            '',
            'if cloudant_url and cloudant_apikey:',
            '    cloudant_client = CloudantV1.new_instance(service_name="cloudant")',
            '    logger.info("Cloudant client initialized.")',
            'else:',
            '    cloudant_client = None',
            '    logger.warning("Cloudant credentials not configured.")',
            '',
        ])

    if has_watsonx:
        lines.extend([
            '# ── watsonx.ai Client ──',
            'watsonx_url = os.getenv("WATSONX_URL", "")',
            'watsonx_apikey = os.getenv("WATSONX_API_KEY", "")',
            'watsonx_project = os.getenv("WATSONX_PROJECT_ID", "")',
            '',
            'if watsonx_url and watsonx_apikey:',
            '    watsonx_client = WatsonxAI(url=watsonx_url, api_key=watsonx_apikey)',
            '    logger.info("watsonx.ai client initialized.")',
            'else:',
            '    watsonx_client = None',
            '    logger.warning("watsonx.ai credentials not configured.")',
            '',
        ])

    # Add security middleware for sensitive data
    if sensitivity in ("PHI", "PCI"):
        lines.extend([
            '# ── Security Middleware (Required for PHI/PCI) ──',
            'from fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware',
            'from starlette.middleware.cors import CORSMiddleware',
            '',
            'app.add_middleware(HTTPSRedirectMiddleware)',
            'app.add_middleware(',
            '    CORSMiddleware,',
            '    allow_origins=["https://your-domain.com"],  # Restrict to known origins',
            '    allow_methods=["GET", "POST"],',
            ')',
            '',
        ])

    lines.extend([
        '# ── Health Check Endpoint ──',
        '@app.get("/health")',
        'async def health():',
        '    return {"status": "healthy", "version": "1.0.0"}',
        '',
        '',
        '# ── Main API Endpoint ──',
        'class RequestPayload(BaseModel):',
        '    query: str',
        '',
        '@app.post("/api/process")',
        'async def process(payload: RequestPayload):',
        '    logger.info(f"Processing request: {payload.query[:50]}...")',
        '    # TODO: Implement your business logic here',
        '    return {"status": "processed", "input": payload.query}',
        '',
        '',
        'if __name__ == "__main__":',
        '    import uvicorn',
        '    uvicorn.run(app, host="0.0.0.0", port=8080)',
    ])

    return "\n".join(lines)


def _generate_requirements_txt(manifest: dict) -> str:
    """Generate requirements.txt based on detected services."""
    services = manifest.get("services", [])
    reqs = [
        "fastapi>=0.104.0",
        "uvicorn>=0.24.0",
        "pydantic>=2.0",
        "python-dotenv>=1.0",
        "httpx>=0.25.0",
    ]

    if any("Cloudant" in s.get("service_name", "") for s in services):
        reqs.append("ibmcloudant>=0.8.0")

    if any("watsonx" in s.get("service_name", "") for s in services):
        reqs.append("ibm-watsonx-ai>=0.0.60")

    return "\n".join(reqs)


def _generate_readme(manifest: dict, sensitivity: str) -> str:
    """Generate a project-specific README."""
    project_name = manifest.get("project_name", "trustbuild-app")
    services = manifest.get("services", [])
    cost = manifest.get("estimated_monthly_cost", "N/A")

    lines = [
        f"# {project_name}",
        f"",
        f"> Auto-generated by IBM TrustBuild | Governance: COMPLIANT | Sensitivity: {sensitivity}",
        f"",
        f"## Architecture",
        f"",
        f"| Service | Role | Plan |",
        f"|---------|------|------|",
    ]

    for svc in services:
        lines.append(f"| {svc.get('service_name', 'Unknown')} | {svc.get('role', '')} | {svc.get('plan', '')} |")

    lines.extend([
        f"",
        f"**Estimated Monthly Cost:** ${cost}",
        f"",
        f"## Setup",
        f"",
        f"1. Copy `.env.example` to `.env` and fill in your IBM Cloud credentials",
        f"2. Run `pip install -r requirements.txt`",
        f"3. Run `python main.py`",
        f"",
        f"## Deployment",
        f"",
        f"Use the provided Terraform scripts to provision IBM Cloud infrastructure,",
        f"then deploy the container using IBM Code Engine.",
    ])

    return "\n".join(lines)


def _generate_ibm_cli_commands(manifest: dict) -> list:
    """Generate the IBM Cloud CLI commands to provision the environment."""
    commands = [
        "# ── IBM TrustBuild: Provisioning Commands ──",
        "",
        "# 1. Login to IBM Cloud",
        "ibmcloud login -a api.ng.bluemix.net",
        "",
        "# 2. Target your resource group",
        "ibmcloud target -g <YOUR_RESOURCE_GROUP>",
        "",
        "# 3. Create a Code Engine project",
        "ibmcloud ce project create --name trustbuild-project",
        "ibmcloud ce project select --name trustbuild-project",
    ]

    services = manifest.get("services", [])
    networking = manifest.get("networking", {})

    for svc in services:
        if "Cloudant" in svc.get("service_name", ""):
            plan = svc.get("plan", "standard")
            commands.extend([
                "",
                f"# 4. Create IBM Cloudant ({plan})",
                f'ibmcloud resource service-create trustbuild-cloudant cloudant {plan} --location us-south',
                'ibmcloud resource service-key-create trustbuild-cloudant-key cloudant --instance-name trustbuild-cloudant',
            ])

    if networking.get("vpc_enabled"):
        commands.extend([
            "",
            "# 5. Create VPC for network isolation",
            'ibmcloud is vpc-create trustbuild-vpc',
            'ibmcloud is subnet-create trustbuild-subnet trustbuild-vpc --zone us-south-1 --ipv4-address-count 256',
        ])

    commands.extend([
        "",
        "# 6. Build and push container image",
        'ibmcloud cr build -t us.icr.io/<YOUR_NAMESPACE>/trustbuild-app:latest .',
        "",
        "# 7. Deploy to Code Engine",
        'ibmcloud ce service create --name trustbuild-app --image us.icr.io/<YOUR_NAMESPACE>/trustbuild-app:latest --port 8080',
        "",
        "# 8. Get the deployment URL",
        'ibmcloud ce service get --name trustbuild-app',
    ])

    return commands


def run_code_synthesis(governance_report: dict, intent_result: dict) -> StageResult:
    """
    Execute Stage 4: Generate the full deployment kit.

    Only proceeds if governance status is PASSED or CORRECTED.
    Uses the corrected manifest (if any) as the source of truth.

    Args:
        governance_report: Output from Stage 3 (GovernanceReport as dict).
        intent_result: Output from Stage 1 (for sensitivity context).

    Returns:
        StageResult containing the CodeSynthesisResult with all generated files.
    """
    start_time = time.time()
    logger.info("[Stage 4] Starting secure code synthesis...")

    try:
        # Verify governance approval
        gov_status = governance_report.get("status", "failed")
        if gov_status == "failed":
            duration_ms = int((time.time() - start_time) * 1000)
            return StageResult(
                stage_id=4,
                stage_name="Secure Code Synthesis",
                status=StageStatus.FAILED,
                duration_ms=duration_ms,
                result={},
                error="Code synthesis blocked: Governance Guardrail did not approve the architecture."
            )

        # Use the corrected manifest (post-governance)
        manifest = governance_report.get("corrected_manifest", {})
        sensitivity = intent_result.get("detected_sensitivity", "public")

        logger.info(f"[Stage 4] Generating code for sensitivity={sensitivity}, status={gov_status}")

        # "Call" granite-20b-code (in simulation, this confirms the model invocation)
        watsonx.generate(
            prompt=f"Generate deployment code for: {manifest.get('project_name', 'app')}",
            model_id=watsonx.MODEL_CODE,
            max_tokens=2048
        )

        # Generate all files using intelligent templates
        files: list[GeneratedFile] = []

        # 1. Dockerfile
        dockerfile_content = _generate_dockerfile(manifest, sensitivity)
        files.append(GeneratedFile(
            filename="Dockerfile",
            filepath="./Dockerfile",
            language="dockerfile",
            content=dockerfile_content,
            description="Security-hardened container definition for IBM Code Engine deployment"
        ))

        # 2. Terraform
        terraform_content = _generate_terraform(manifest, sensitivity)
        files.append(GeneratedFile(
            filename="main.tf",
            filepath="./terraform/main.tf",
            language="hcl",
            content=terraform_content,
            description="Infrastructure-as-Code for provisioning IBM Cloud resources"
        ))

        # 3. Application boilerplate
        app_content = _generate_app_boilerplate(manifest, sensitivity)
        files.append(GeneratedFile(
            filename="main.py",
            filepath="./app/main.py",
            language="python",
            content=app_content,
            description="FastAPI application with IBM SDK integrations pre-configured"
        ))

        # 4. Requirements
        reqs_content = _generate_requirements_txt(manifest)
        files.append(GeneratedFile(
            filename="requirements.txt",
            filepath="./app/requirements.txt",
            language="text",
            content=reqs_content,
            description="Python dependencies including IBM Cloud SDKs"
        ))

        # 5. README
        readme_content = _generate_readme(manifest, sensitivity)
        files.append(GeneratedFile(
            filename="README.md",
            filepath="./README.md",
            language="markdown",
            content=readme_content,
            description="Project documentation with architecture overview and setup guide"
        ))

        # 6. IBM CLI commands
        cli_commands = _generate_ibm_cli_commands(manifest)

        # Build the result
        result = CodeSynthesisResult(
            files=files,
            deployment_commands=cli_commands,
            readme_summary=f"Auto-generated deployment kit for '{manifest.get('project_name', 'app')}' "
                          f"with {len(manifest.get('services', []))} IBM Cloud services. "
                          f"Compliance: {gov_status.upper()}. Sensitivity: {sensitivity}.",
            model_used=watsonx.MODEL_CODE,
            tokens_used=850
        )

        duration_ms = int((time.time() - start_time) * 1000)
        logger.info(f"[Stage 4] Completed in {duration_ms}ms. Generated {len(files)} files.")

        return StageResult(
            stage_id=4,
            stage_name="Secure Code Synthesis",
            status=StageStatus.PASSED,
            duration_ms=duration_ms,
            result=result.model_dump()
        )

    except Exception as e:
        duration_ms = int((time.time() - start_time) * 1000)
        logger.error(f"[Stage 4] Unexpected error: {e}")
        return StageResult(
            stage_id=4,
            stage_name="Secure Code Synthesis",
            status=StageStatus.FAILED,
            duration_ms=duration_ms,
            result={},
            error=str(e)
        )
